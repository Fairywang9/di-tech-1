# Di-tech 问题思考与分解   

## 1 主要问题：  
[赛题详情](http://research.xiaojukeji.com/competition/detail.action?competitionId=DiTech2016)

问题定义：
> 乘客打开滴滴出行app，输入出发地和目的地并点击“呼叫”后就完成一次发单(request)，有司机接单后就完成一次应答(answer)。
将一个城市划分为n个互不重叠的正方形区域D={d1,d2,⋯,dn }，将每一天的24小时划分为144个10分钟长的时间片t1,t2,⋯,t144。
对于区域di，在时间片tj，有rij个乘客发单，有aij个司机成功应答了aij次发单。
对于区域di，在时间片tj，定义需求demandij=rij，供给supplyij=aij，则有供需缺口gapij：gapij = rij - aij
给定每个区域在时间片tj,tj-1...的各项数据，预测gapi,j+1, ∀di∈D。

注解：
给定过去一段时间该城市所有地区的订单信息，预测该城市某一地区下一时间段的**供需缺口**。  
限定因素：
- 滴滴做了简化，已经给区域和时间分片了。关于区域和区域的互相影响，暂时不做考虑。
- 指定区域：不同功能的区域左右了出行需求，会影响拥堵情况。根据POI表知道该区域主要功能；  
- 指定时间：该时间段的天气，可能左右出行方式，由weather表得知；该时间段该区域的拥堵情况，可能左右出行方式，可由traffic表可知；  

所需：确定X和Y：  

Y：供需缺口gap，由demand－supply得到。指定区域和时间时，demand即order表中的记录数，supply即order表中driver非空（不等于null）的记录数。  

所以，Y需要计算出来。（对数据进行预处理）

X：出发地（poi情况）和目的地（poi情况）、价格、time、拥堵情况、天气情况（天气、温度、pm25）

## 2 思考过程  

### 2.1 总体考虑   

#### 基准预测值：  

* 单单采用常识性基本均值估计的方式，不采用任何机器学习方式，进行预测，获得base（基准）预测值。测试结果。
* 常识分析： 经验性分析

#### 步骤：  

1. 当前时间转为时间片；
2. 以时间片和区域为index，并汇总各时间片内的gap；
3. 以时间片和区域为index，汇总各时间片内的weather（两个取平均值？）
4. 以时间片和区域为index，汇总各时间片内的traffic（有处在同一时间片内的取平均值？分4个级别保持不变）
5. 得到一个以时间片和区域为index、包含weather和traffic和gap值的超级表
6. 将时间片从index恢复为普通数据，并拆解成daytype和时间片两部分，daytype即上面说的节假日工作日编码  
7. 区域，从POI中得到区域类型值，作为输入
8. X为：daytype、时间片、weather（有3项）、traffic（有4项）
y为gap
9. 模型建立与调试，使用分裂数据为（train和cv）的方式调试
10. 输入指定时间片及对应时间的weather河traffic进行结果预测

### 2.1 数据  

区域信息的两张表：`cluster_map`和`poi_data`和时间无关，是统一数据。  

`order_data`、`traffic_data`、`weather_data`这三种表以天为单位，1天1张表；   

 `weather_data`每5分钟1条数据；其他两种则不一定，根据实际情况确定。  

对前21天数据，是否应该采取像“天龙八部”一样的合并方式，用一个list合并一下？  

对于分布在不同类型表中的数据（X的众多组成），是否应该用数据库关联放到一张表里？  

poi这个复杂的因素，如何处理？  

区域：指定区域可以确定天气、拥堵等情况。那么跨区域接单要如何对待？噢，实际计算时以有没有人应答为标准。只要无人应答，即缺。不会去管是否有人跑满城来应答。

#### 数据量考量  

我用linux命令行先查看了数据量，每天的订单数据大概30万+，如果要按照10分钟的时间片将数据做聚合预处理，可以先抽样看看每个变量的具体分布符不符合高斯分布，尝试下aggregate by mean。

#### 测试上传  

我先测试了上传，使用FAQ 中的 test.csv 改造后的结果。  
测试程序：`/test_upload.ipynb`

#### 时间片转换  

失败思路：因为不能向量化操作，用for。而1.1就是50万，不知道要运行多久，还有后面那么多天……所以for应该不是个好主意。

两种正确思路：  

- 用 output() 函数，关键是 `order.time.apply(lambda x: x.hour*6 + int(x.minute/10)+1)`  
- `(delta.dt.seconds/600).astype(np.int64) + 1`

处理程序：` `  

#### POI数据预处理  

poi的class共有176种分类，我打算生成对应dummy variable的table。  
结果文件：`/region_data.csv`  
处理程序：` `  

#### POI数据分析

对66*176表格，先进行feature scaling：`(x(i)-mean)/range`……再考虑各种求和归类。  

处理程序：` `  



